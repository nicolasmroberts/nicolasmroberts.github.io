r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
l1 <- unitUniform()
p1 <- unitUniform()
p1 <- unit(p1 - (p1 %*% l1) * l1)
p2 <- unitUniform()
p2 <- unit(p2 - (p2 %*% l1) * l1)
l2 <- unitUniform()
l2 <- unit(l2 - (l2 %*% p2) * p2)
r1 <- rotationProjected(rbind(p1, l1, vectorCross(p1, l1)))
r2 <- rotationProjected(rbind(p2, l2, vectorCross(p2, l2)))
r3 <- rotationProjected(rbind(p2, l1, vectorCross(p2, l1)))
rs <- rotationGeodesicCurve(r1, r2, 10)
rss <- list()
for (r in rs)
rss <- c(rss, rotationIsotropicFisher(r, 8, 5))
q <- rotationUniform()
r3s <- rotationFisher(r3, q %*% diag(c(10, 2, 2)) %*% t(q), 50)
rotationDistance(rotationMean(c(rss, r3s))$rBar, rotationProjectedMean(c(rss, r3s)))
ps <- lapply(c(rss, r3s), function(r) r[1,])
ls <- lapply(c(rss, r3s), function(r) r[2,])
plotEqualArea(points=c(ps, ls),colors=c(replicate(length(ps), "red"), replicate(length(ls), "green")))
plotRotation(points=c(rss, r3s))
write.csv(lapply(c(rss, r3s), strikeDipRakeDegFromRotation), "slicksSynthetic.csv")
synth <- sapply(c(rss, r3s), strikeDipRakeDegFromRotation)
synth
t(synth)
write.csv(t(synth), "slicksSynthetic.csv", row.names=FALSE)
synthData <- dataFromFile("slicksSynthetic.csv")
synthData
rotMean <- rotationMean(synthData$rotation)$rBar
projMean <- rotationProjectedMean(synthData$rotation)
rotationDistance(rotMean, projMean) / degree
plotEqualAreaTwo(ps, ls)
plotEqualAreaTwo(synthData$pole, synthData$direction)
plotEqualVolume(synthData$rotation)
plotRotation(synthData$rotation)
plotOrientation(clusterData$rotation, group=groupPlaneRay)
clusterData <- dataFromFile("clustersSynthetic.csv")
rotMean <- rotationMean(clusterData$rotation)$rBar
projMean <- rotationProjectedMean(clusterData$rotation)
rotationDistance(rotMean, projMean) / degree
plotOrientation(clusterData$rotation, group=groupPlaneRay)
plotRotation(c(clusterData$rotation, list(rotMean, projMean)),
colors=c(replicate(length(clusterData$rotation), "white"), "red", "cyan"))
plotRotation(c(clusterData$rotation, list(rotMean, projMean)),
colors=c(replicate(length(clusterData$rotation), "white"), "yellow", "green"))
plotEqualAreaTwo(clusterData$pole, clusterData$direction)
rippleData <- dataFromFile("currentRipplesSynthetic.csv")
rotMean <- rotationMean(rippleData$rotation)$rBar
projMean <- rotationProjectedMean(rippleData$rotation)
rotationDistance(rotMean, projMean) / degree
plotRotation(c(rippleData$rotation, list(rotMean, projMean)),
colors=c(replicate(length(rippleData$rotation), "white"), "yellow", "green"))
plotEqualAreaTwo(rippleData$pole, rippleData$direction)
rippleDists <- matrixOfDistances(rippleData$rotation, rotationDistance, verbose=TRUE)
clus <- clusteringDBSCAN(rippleDists, 0.5, 3)
plotRotationClustering(rippleData$rotation, clus)
plotOrientationClustering(rippleData$rotation, clus, groupTrivial)
plotOrientationClustering(rippleData$rotation, clus, groupTrivial)
clus
firstRots <- rippleData$rotation[clus[[1]]]
rotMean <- rotationMean(firstRots)$rBar
projMean <- rotationProjectedMean(firstRots)
rotationDistance(rotMean, projMean) / degree
plotRotation(c(firstRots, list(rotMean, projMean)),
colors=(replicate(length(firstRots), "white"), "yellow", "green"))
plotRotation(c(firstRots, list(rotMean, projMean)),
colors=c(replicate(length(firstRots), "white"), "yellow", "green"))
rippleDists <- matrixOfDistances(rippleData$rotation, rotationDistance)
clus <- clusteringDBSCAN(rippleDists, radius=0.5, minPoints=3)
plotOrientationClustering(rippleData$rotation, clus, groupTrivial)
plotRotationKambC(rippleData$rotation, mult=6)
plotRotationKambC(rippleData$rotation, mult=6, nonAdapt=4, adapt=2)
plotRotationKambC(rippleData$rotation, mult=9, nonAdapt=4, adapt=2)
plotRotationKambC(rippleData$rotation, mult=3, nonAdapt=4, adapt=2)
plotRotationKambC(rippleData$rotation, mult=9)
curves <- lapply(wiszRots, function(r) rotationGeodesicSteps(rotMean, r, 10))
curves <- lapply(wiszRots, function(r) rotationGeodesicCurve(rotMean, r, 10))
plotRotation(points=wiszRots, curves=curves)
rotMean <- rotationMean(wiszRots)$rBar
curves <- lapply(wiszRots, function(r) rotationGeodesicCurve(rotMean, r, 10))
plotRotation(points=wiszRots, curves=curves)
r <- rotationUniform()
q <- rotationUniform()
angleAxisFromRotation(r %*% t(q))$a / degree
plotRotation(points=list(r, q), curves=list(rotationGeodesicCurve(r, q, 100)))
r <- rotationUniform()
q <- rotationUniform()
angleAxisFromRotation(r %*% t(q))$a / degree
rotationDistance(r, q) / degree
plotRotation(points=list(r, q), curves=list(rotationGeodesicCurve(r, q, 100)))
r <- rotationUniform()
q <- rotationUniform()
angleAxisFromRotation(r %*% t(q))$a / degree
rotationDistance(r, q) / degree
plotRotation(points=list(r, q), curves=list(rotationGeodesicCurve(r, q, 100)))
r <- rotationUniform()
q <- rotationUniform()
angleAxisFromRotation(r %*% t(q))$a / degree
rotationDistance(r, q) / degree
plotRotation(points=list(r, q), curves=list(rotationGeodesicCurve(r, q, 100)))
r <- rotationUniform()
q <- rotationUniform()
angleAxisFromRotation(r %*% t(q))$a / degree
rotationDistance(r, q) / degree
plotEqualAreaThree(list(r[,1], q[,1]), list(r[,2], q[,2]), list(r[,3], q[,3]))
r <- rotationUniform()
q <- rotationUniform()
angleAxisFromRotation(r %*% t(q))$a / degree
rotationDistance(r, q) / degree
firstColumns <- list(r[,1], q[,1])
secondColumns <- list(r[,2], q[,2])
thirdColumns <- list(r[,3], q[,3])
plotEqualAreaThree(firstColumns, secondColumns, thirdColumns, curves=list(firstColumns, secondColumns, thirdColumns))
r <- rotationUniform()
q <- rotationUniform()
angleAxisFromRotation(r %*% t(q))$a / degree
rotationDistance(r, q) / degree
curve <- rotationGeodesicCurve(r, q, 100)
plotRotation(points=list(r, q), curves=list(curve))
firstColumns <- lapply(curve, function(r) r[,1])
secondColumns <- lapply(curve, function(r) r[,2])
thirdColumns <- lapply(curve, function(r) r[,3])
plotEqualAreaThree(list(r[,1], q[,1]), list(r[,2], q[,2]), list(r[,3], q[,3]),
curves=list(firstColumns, secondColumns, thirdColumns))
angleAxisFromRotation(r %*% t(q))$u
r <- rotationUniform()
q <- rotationUniform()
angleAxisFromRotation(q %*% t(t))$a / degree
angleAxisFromRotation(q %*% t(r))$a / degree
rotationDistance(r, q) / degree
angleAxisFromRotation(q %*% t(r))$u
rotMean <- rotationMean(wiszRots)$rBar
curves <- lapply(wiszRots, function(r) rotationGeodesicCurve(rotMean, r, 10))
plotRotation(points=wiszRots, curves=curves)
trendPlungeDegFromCartesian(angleAxisFromRotation(q %*% t(r))$u)
angleAxisFromRotation(q %*% t(r))$u
trendPlungeDegFromCartesian(angleAxisFromRotation(q %*% t(r))$u)
r <- rotationUniform()
q <- rotationUniform()
angleAxisFromRotation(q %*% t(r))$a / degree
rotationDistance(r, q) / degree
curve <- rotationGeodesicCurve(r, q, 100)
firstColumns <- lapply(curve, function(r) r[,1])
secondColumns <- lapply(curve, function(r) r[,2])
thirdColumns <- lapply(curve, function(r) r[,3])
plotEqualAreaThree(list(r[,1], q[,1]), list(r[,2], q[,2]), list(r[,3], q[,3]),
curves=list(firstColumns, secondColumns, thirdColumns))
angleAxisFromRotation(q %*% t(r))$u
trendPlungeDegFromCartesian(angleAxisFromRotation(q %*% t(r))$u)
plotRotation(points=list(r, q), curves=list(curve))
curves <- lapply(wiszRots, function(r) rotationGeodesicCurve(rotMean, r, 10))
plotRotation(points=wiszRots, curves=curves)
matrixMean(wiszRots)
projMean <- rotationProjectedMean(wiszRots)
projMean
matrixMean(wiszRots)
projMean <- rotationProjectedMean(wiszRots)
projMean
rotationDistance(rotMean, projMean) / degree
plotRotation(c(wiszRots, list(rotMean, projMean)),
colors=c(replicate(length(wiszRots), "white"), "red", "cyan"))
rippleData <- dataFromFile("currentRipplesSynthetic.csv")
rotMean <- rotationMean(rippleData$rotation)$rBar
projMean <- rotationProjectedMean(rippleData$rotation)
rotationDistance(rotMean, projMean) / degree
plotRotation(c(rippleData$rotation, list(rotMean, projMean)),
colors=c(replicate(length(rippleData$rotation), "white"), "yellow", "green"))
plotEqualAreaTwo(rippleData$pole, rippleData$direction)
firstRots <- rippleData$rotation[clus[[1]]]
rotMean <- rotationMean(firstRots)$rBar
projMean <- rotationProjectedMean(firstRots)
rotationDistance(rotMean, projMean) / degree
plotRotation(c(firstRots, list(rotMean, projMean)),
colors=c(replicate(length(firstRots), "white"), "yellow", "green"))
curves <- lapply(wiszRots, function(r) rotationGeodesicCurve(rotMean, r, 10))
plotRotation(points=wiszRots, curves=curves)
wiszData <- dataFromFile("wiszFollins.tsv")
wiszRots <- lapply(wiszData$rotation, orientationNearest, wiszData$rotation[[1]], groupPlaneLine)
rotMean <- rotationMean(wiszRots)$rBar
curves <- lapply(wiszRots, function(r) rotationGeodesicCurve(rotMean, r, 10))
plotRotation(points=wiszRots, curves=curves)
rippleData <- dataFromFile("currentRipplesSynthetic.csv")
rotMean <- rotationMean(rippleData$rotation)$rBar
projMean <- rotationProjectedMean(rippleData$rotation)
rotationDistance(rotMean, projMean) / degree
# The data set is multimodal, meaning that it contains multiple regions of high density. So the very concept of mean is meaningless. We should have checked unimodality before even computing the mean.
plotRotation(c(rippleData$rotation, list(rotMean, projMean)),
colors=c(replicate(length(rippleData$rotation), "white"), "yellow", "green"))
plotEqualAreaTwo(rippleData$pole, rippleData$direction)
plotRotationKambC(rippleData$rotation, mult=9)
r <- rotationUniform()
q <- rotationUniform()
angleAxisFromRotation(q %*% t(r))$a / degree
rotationDistance(r, q) / degree
curve <- rotationGeodesicCurve(r, q, 100)
plotRotation(points=list(r, q), curves=list(curve))
firstColumns <- lapply(curve, function(r) r[,1])
secondColumns <- lapply(curve, function(r) r[,2])
thirdColumns <- lapply(curve, function(r) r[,3])
plotEqualAreaThree(list(r[,1], q[,1]), list(r[,2], q[,2]), list(r[,3], q[,3]),
curves=list(firstColumns, secondColumns, thirdColumns))
wiszData <- dataFromFile("wiszFollins.tsv")
wiszRots <- lapply(wiszData$rotation, orientationNearest, wiszData$rotation[[1]], groupPlaneLine)
rotMean <- rotationMean(wiszRots)$rBar
rotMean
# Here's your intuition for the Frechet mean. At any point R in the space of rotations, the 'variance' of the data set is a measure of how spread about the data are around R. It is proportional to the sum of the squared distances from R to the data. The Frechet mean is the point R that minimizes this variance. In the following plot, the Frechet mean is at the center of the 'spider', and the variance is proportional to the sum of the squared lengths of the spider legs.
curves <- lapply(wiszRots, function(r) rotationGeodesicCurve(rotMean, r, 10))
plotRotation(points=wiszRots, curves=curves)
rippleData <- dataFromFile("currentRipplesSynthetic.csv")
rotMean <- rotationMean(rippleData$rotation)$rBar
projMean <- rotationProjectedMean(rippleData$rotation)
rotationDistance(rotMean, projMean) / degree
firstRots <- rippleData$rotation[clus[[1]]]
rotMean <- rotationMean(firstRots)$rBar
projMean <- rotationProjectedMean(firstRots)
rotationDistance(rotMean, projMean) / degree
plotRotation(c(firstRots, list(rotMean, projMean)),
colors=c(replicate(length(firstRots), "white"), "yellow", "green"))
rippleData <- dataFromFile("currentRipplesSynthetic.csv")
rotMean <- rotationMean(rippleData$rotation)$rBar
projMean <- rotationProjectedMean(rippleData$rotation)
rotationDistance(rotMean, projMean) / degree
plotEqualAreaTwo(rippleData$pole, rippleData$direction)
plotRotation(c(rippleData$rotation, list(rotMean, projMean)),
colors=c(replicate(length(rippleData$rotation), "white"), "yellow", "green"))
clus
firstRots <- rippleData$rotation[clus[[1]]]
secondRots <- rippleData$rotation[clus[[2]]]
thirdRots <- rippleData$rotation[clus[[3]]]
firstRots <- rippleData$rotation[clus[[1]]]
secondRots <- rippleData$rotation[clus[[2]]]
thirdRots <- rippleData$rotation[clus[[3]]]
firstDirs <- lapply(firstRots, function(r) r[1,])
secondDirs <- lapply(secondRots, function(r) r[1,])
thirdDirs <- lapply(thirdRots, function(r) r[1,])
plotEqualAreaThree(firstDirs, secondDirs, thirdDirs)
plotOrientationClustering(rippleData$rotation, clus, groupTrivial)
r <- rotationUniform()
q <- rotationUniform()
angleAxisFromRotation(q %*% t(r))$a / degree
rotationDistance(r, q) / degree
curve <- rotationGeodesicCurve(r, q, 100)
plotRotation(points=list(r, q), curves=list(curve))
plotRotation(points=list(r, q), curves=list(curve))
plotRotationKambC(rippleData$rotation, mult=9)
average
mean
arithmeticMean
